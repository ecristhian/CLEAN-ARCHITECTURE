{"version":3,"sources":["core/Interface.js"],"names":[],"mappings":";;;;;;;;;;AAIA;;;;AACA;;;;;;;;;;;;;;;;;IAWqB,S;;;;;;;;;;;;;AAYnB,qBAAY,aAAZ,EAA2B,IAA3B,EAAiC,cAAjC,EAAiD;AAAA;;;;;;AAM/C,SAAK,aAAL,GAAqB,aAArB;;;;;;AAMA,SAAK,IAAL,GAAY,IAAZ;;;;;;AAMA,SAAK,cAAL,GAAsB,cAAtB;AACD;;;;;;;;;;;;;uCAUkB;AACjB,aAAO,KAAK,aAAZ;AACD;;;;;;;;8BAKS;AACR,aAAO,KAAK,IAAZ;AACD;;;;;;;;wCAKmB;AAClB,aAAO,KAAK,cAAZ;AACD;;;;;;;;;;;;;;4BAYc,W,EAAa;AAC1B,aAAO,UAAU,MAAV,0BAAgC,WAAhC,CAAP;AACD;;;;;;;;;;;2BAQa,a,EAAe,W,EAAa;AACxC,UAAI,CAAC,iBAAE,UAAF,CAAa,aAAb,CAAL,EAAkC;AAChC,cAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACD;AACD,UAAM,YAAY,IAAI,aAAJ,EAAlB;AACA,UAAM,gBAAgB,YAAY,OAAZ,KAAwB,cAAc,IAA5D;AACA,aAAO,YAAY,OAAZ,CAAP;AACA,WAAK,IAAM,IAAX,IAAmB,WAAnB,EAAgC;AAC9B,YAAI,OAAO,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,WAArC,EAAkD,IAAlD,CAAJ,EAA6D;AAC3D,cAAI,iBAAE,UAAF,CAAa,YAAY,IAAZ,CAAb,CAAJ,EAAqC;AACnC,sBAAU,IAAV,IAAkB,YAAY,IAAZ,CAAlB;AACD,WAFD,MAEO;AACL,kBAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;AACF;AACF;AACD,UAAM,mBAAmB,SAAnB,gBAAmB,GAAW,CACnC,CADD;AAEA,uBAAiB,SAAjB,GAA6B,SAA7B;AACA,uBAAiB,WAAjB,GAA+B,gBAA/B;AACA,uBAAE,MAAF,CAAS,gBAAT,EAA2B;AACzB,sBAAc,wBAAW;AACvB,iBAAO,iBAAiB,UAAxB;AACD;AAHwB,OAA3B;AAKA,UAAM,eAAe,IAAI,SAAJ,CAAc,gBAAd,EAAgC,aAAhC,EAA+C,cAAc,YAAd,EAA/C,CAArB;AACA,aAAO,cAAP,CAAsB,gBAAtB,EAAwC,YAAxC,EAAsD;AACpD,eAAO,YAD6C;AAEpD,kBAAU,KAF0C;AAGpD,oBAAY,KAHwC;AAIpD,sBAAc;AAJsC,OAAtD;AAMA,gBAAU,2BAAV,CAAsC,GAAtC,CAA0C,gBAA1C,EAA4D,YAA5D;AACA,aAAO,gBAAP;AACD;;;;;;;;;;;wBAQU,a,EAAe;AACxB,aAAO,UAAU,2BAAV,CAAsC,GAAtC,CAA0C,aAA1C,CAAP;AACD;;;;;;;;;;;;;;;;;;AA3HkB,S,CAwIZ,2B,GAA8B,IAAI,OAAJ,E;kBAxIlB,S","file":"core/Interface.js","sourcesContent":["//-------------------------------------------------------------------------------\n// Imports\n//-------------------------------------------------------------------------------\n\nimport _ from 'lodash';\nimport Implementable from './Implementable';\n\n\n//-------------------------------------------------------------------------------\n// Class\n//-------------------------------------------------------------------------------\n\n/**\n * @class\n * @template {T extends Implementable}\n */\nexport default class Interface {\n\n  //-------------------------------------------------------------------------------\n  // Constructor\n  //-------------------------------------------------------------------------------\n\n  /**\n   * @constructs\n   * @param {function(new:Implementable)} implementable\n   * @param {string} name\n   * @param {Interface=} superinterface\n   */\n  constructor(implementable, name, superinterface) {\n\n    /**\n     * @private\n     * @type {function(new:Implementable)}\n     */\n    this.implementable = implementable;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * @private\n     * @type {Interface}\n     */\n    this.superinterface = superinterface;\n  }\n\n\n  //-------------------------------------------------------------------------------\n  // Getters and Setters\n  //-------------------------------------------------------------------------------\n\n  /**\n   * @return {function(new:Implementable)}\n   */\n  getImplementable() {\n    return this.implementable;\n  }\n\n  /**\n   * @return {string}\n   */\n  getName() {\n    return this.name;\n  }\n\n  /**\n   * @return {Interface}\n   */\n  getSuperinterface() {\n    return this.superinterface;\n  }\n\n\n  //-------------------------------------------------------------------------------\n  // Public Static Methods\n  //-------------------------------------------------------------------------------\n\n  /**\n   * @static\n   * @param {Object.<string, function(..):*>} declaration\n   * @return {function(new:Implementable)}\n   */\n  static declare(declaration) {\n    return Interface.extend(Implementable, declaration);\n  }\n\n  /**\n   * @static\n   * @param {function(new:Implementable)} implementable\n   * @param {Object.<string, function(..):*>} declaration\n   * @return {function(new:Implementable)}\n   */\n  static extend(implementable, declaration) {\n    if (!_.isFunction(implementable)) {\n      throw new Error('implementable must be a function');\n    }\n    const prototype = new implementable();\n    const interfaceName = declaration['_name'] || implementable.name;\n    delete declaration['_name'];\n    for (const name in declaration) {\n      if (Object.prototype.hasOwnProperty.call(declaration, name)) {\n        if (_.isFunction(declaration[name])) {\n          prototype[name] = declaration[name];\n        } else {\n          throw new Error('Interface can only declare functions');\n        }\n      }\n    }\n    const newImplementable = function() {\n    };\n    newImplementable.prototype = prototype;\n    newImplementable.constructor = newImplementable;\n    _.assign(newImplementable, {\n      getInterface: function() {\n        return newImplementable._interface;\n      }\n    });\n    const newInterface = new Interface(newImplementable, interfaceName, implementable.getInterface());\n    Object.defineProperty(newImplementable, '_interface', {\n      value: newInterface,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Interface.implementableToInterfaceMap.set(newImplementable, newInterface);\n    return newImplementable;\n  }\n\n  /**\n   * @static\n   * @param {function(new:T)} implementable\n   * @return {Interface<T>}\n   * @template {T}\n   */\n  static get(implementable) {\n    return Interface.implementableToInterfaceMap.get(implementable);\n  }\n\n\n  //-------------------------------------------------------------------------------\n  // Private Static Methods\n  //-------------------------------------------------------------------------------\n\n  /**\n   * @private\n   * @static\n   * @type {WeakMap<function(new:T), Interface<T>>}\n   * @template {T}\n   */\n  static implementableToInterfaceMap = new WeakMap();\n}\n"],"sourceRoot":"/source/"}